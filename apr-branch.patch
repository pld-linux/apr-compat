Index: strings/apr_cpystrn.c
===================================================================
--- strings/apr_cpystrn.c	(.../tags/1.2.2)	(wersja 358281)
+++ strings/apr_cpystrn.c	(.../branches/1.2.x)	(wersja 358281)
@@ -169,6 +169,7 @@
 
     /*  determine first argument */
     for (argnum = 0; argnum < (numargs-1); argnum++) {
+        SKIP_WHITESPACE(cp);
         CHECK_QUOTATION(cp, isquoted);
         ct = cp;
         DETERMINE_NEXTSTRING(cp, isquoted);
@@ -177,7 +178,6 @@
         apr_cpystrn((*argv_out)[argnum], ct, cp - ct);
         cleaned = dirty = (*argv_out)[argnum];
         REMOVE_ESCAPE_CHARS(cleaned, dirty, escaped);
-        SKIP_WHITESPACE(cp);
     }
     (*argv_out)[argnum] = NULL;
 
Index: CHANGES
===================================================================
--- CHANGES	(.../tags/1.2.2)	(wersja 358281)
+++ CHANGES	(.../branches/1.2.x)	(wersja 358281)
@@ -1,3 +1,13 @@
+Changes for APR 1.2.3-dev
+
+  *) Bugfix for apr_pollset_poll() on systems that implement pollsets
+     using select(2): properly compute the number of signalled desciptors
+     when one or more of them are both readable and writable.
+     [Dror Shilo <Dror.Shilo ericom.com>, Gerry <gerry everythingsucks.co.uk>]
+
+  *) Fix apr_file_seek() to catch write failures when flushing
+     pending writes for a buffered file.  [Joe Orton]
+
 Changes for APR 1.2.2
 
   *) Fix crash in apr_dir_make_recursive() for relative path
Index: test/testsock.c
===================================================================
--- test/testsock.c	(.../tags/1.2.2)	(wersja 358281)
+++ test/testsock.c	(.../branches/1.2.x)	(wersja 358281)
@@ -84,6 +84,9 @@
 
     rv = apr_socket_create(&sock, sa->family, SOCK_STREAM, APR_PROTO_TCP, p);
     APR_ASSERT_SUCCESS(tc, "Problem creating socket", rv);
+
+    rv = apr_socket_opt_set(sock, APR_SO_REUSEADDR, 1);
+    APR_ASSERT_SUCCESS(tc, "Could not set REUSEADDR on socket", rv);
     
     rv = apr_socket_bind(sock, sa);
     APR_ASSERT_SUCCESS(tc, "Problem binding to port", rv);
Index: test/testdir.c
===================================================================
--- test/testdir.c	(.../tags/1.2.2)	(wersja 358281)
+++ test/testdir.c	(.../branches/1.2.x)	(wersja 358281)
@@ -222,6 +222,7 @@
 static void test_rmkdir_nocwd(abts_case *tc, void *data)
 {
     char *cwd, *path;
+    apr_status_t rv;
 
     APR_ASSERT_SUCCESS(tc, "make temp dir",
                        apr_dir_make("dir3", APR_OS_DEFAULT, p));
@@ -233,13 +234,20 @@
 
     APR_ASSERT_SUCCESS(tc, "change to temp dir", apr_filepath_set(path, p));
 
-    APR_ASSERT_SUCCESS(tc, "remove temp dir", apr_dir_remove(path, p));
+    rv = apr_dir_remove(path, p);
+    /* Some platforms cannot remove a directory which is in use. */
+    if (rv == APR_SUCCESS) {
+        ABTS_ASSERT(tc, "fail to create dir",
+                    apr_dir_make_recursive("foobar", APR_OS_DEFAULT, 
+                                           p) != APR_SUCCESS);
+    }
 
-    ABTS_ASSERT(tc, "fail to create dir",
-                apr_dir_make_recursive("foobar", APR_OS_DEFAULT, 
-                                       p) != APR_SUCCESS);
+    APR_ASSERT_SUCCESS(tc, "restore cwd", apr_filepath_set(cwd, p));
 
-    APR_ASSERT_SUCCESS(tc, "restore cwd", apr_filepath_set(cwd, p));
+    if (rv) {
+        apr_dir_remove(path, p);
+        ABTS_NOT_IMPL(tc, "cannot remove in-use directory");
+    }
 }
 
 
Index: test/testfile.c
===================================================================
--- test/testfile.c	(.../tags/1.2.2)	(wersja 358281)
+++ test/testfile.c	(.../branches/1.2.x)	(wersja 358281)
@@ -766,6 +766,16 @@
     ABTS_ASSERT(tc, "gets should flush buffered write and fail",
                 rv != APR_SUCCESS && rv != APR_EOF);
 
+    /* Likewise for seek. */
+    {
+        apr_off_t offset = 0;
+
+        rv = apr_file_seek(f, APR_SET, &offset);
+    }
+
+    ABTS_ASSERT(tc, "seek should flush buffered write and fail",
+                rv != APR_SUCCESS && rv != APR_EOF);
+
     apr_file_close(f);
 }
 
Index: test/testpoll.c
===================================================================
--- test/testpoll.c	(.../tags/1.2.2)	(wersja 358281)
+++ test/testpoll.c	(.../branches/1.2.x)	(wersja 358281)
@@ -290,6 +290,43 @@
     ABTS_INT_EQUAL(tc, APR_SUCCESS, rv);
 }
 
+static void multi_event_pollset(abts_case *tc, void *data)
+{
+    apr_status_t rv;
+    apr_pollfd_t socket_pollfd;
+    int lrv;
+    const apr_pollfd_t *descs = NULL;
+
+    ABTS_PTR_NOTNULL(tc, s[0]);
+    socket_pollfd.desc_type = APR_POLL_SOCKET;
+    socket_pollfd.reqevents = APR_POLLIN | APR_POLLOUT;
+    socket_pollfd.desc.s = s[0];
+    socket_pollfd.client_data = s[0];
+    rv = apr_pollset_add(pollset, &socket_pollfd);
+    ABTS_INT_EQUAL(tc, APR_SUCCESS, rv);
+
+    send_msg(s, sa, 0, tc);
+
+    rv = apr_pollset_poll(pollset, 0, &lrv, &descs);
+    ABTS_INT_EQUAL(tc, 0, APR_STATUS_IS_TIMEUP(rv));
+    ABTS_INT_EQUAL(tc, 1, lrv);
+    ABTS_PTR_EQUAL(tc, s[0], descs[0].desc.s);
+    ABTS_INT_EQUAL(tc, APR_POLLIN | APR_POLLOUT, descs[0].rtnevents);
+    ABTS_PTR_EQUAL(tc, s[0],  descs[0].client_data);
+
+    recv_msg(s, 0, p, tc);
+
+    rv = apr_pollset_poll(pollset, 0, &lrv, &descs);
+    ABTS_INT_EQUAL(tc, 0, APR_STATUS_IS_TIMEUP(rv));
+    ABTS_INT_EQUAL(tc, 1, lrv);
+    ABTS_PTR_EQUAL(tc, s[0], descs[0].desc.s);
+    ABTS_INT_EQUAL(tc, APR_POLLOUT, descs[0].rtnevents);
+    ABTS_PTR_EQUAL(tc, s[0],  descs[0].client_data);
+
+    rv = apr_pollset_remove(pollset, &socket_pollfd);
+    ABTS_INT_EQUAL(tc, APR_SUCCESS, rv);
+}
+                         
 static void add_sockets_pollset(abts_case *tc, void *data)
 {
     apr_status_t rv;
@@ -520,6 +557,7 @@
 #endif
 
     abts_run_test(suite, setup_pollset, NULL);
+    abts_run_test(suite, multi_event_pollset, NULL);
     abts_run_test(suite, add_sockets_pollset, NULL);
     abts_run_test(suite, nomessage_pollset, NULL);
     abts_run_test(suite, send0_pollset, NULL);
Index: network_io/unix/sockaddr.c
===================================================================
--- network_io/unix/sockaddr.c	(.../tags/1.2.2)	(wersja 358281)
+++ network_io/unix/sockaddr.c	(.../branches/1.2.x)	(wersja 358281)
@@ -596,6 +596,7 @@
         IN6_IS_ADDR_V4MAPPED(&sockaddr->sa.sin6.sin6_addr)) {
         struct sockaddr_in tmpsa;
         tmpsa.sin_family = AF_INET;
+        tmpsa.sin_port = 0;
         tmpsa.sin_addr.s_addr = ((apr_uint32_t *)sockaddr->ipaddr_ptr)[3];
 #ifdef SIN6_LEN
         tmpsa.sin_len = sizeof(tmpsa);
Index: network_io/unix/sockets.c
===================================================================
--- network_io/unix/sockets.c	(.../tags/1.2.2)	(wersja 358281)
+++ network_io/unix/sockets.c	(.../branches/1.2.x)	(wersja 358281)
@@ -422,7 +422,7 @@
     return APR_SUCCESS;
 }
 
-APR_POOL_IMPLEMENT_ACCESSOR(socket);
+APR_POOL_IMPLEMENT_ACCESSOR(socket)
 
 APR_IMPLEMENT_INHERIT_SET(socket, inherit, pool, socket_cleanup)
 
Index: random/unix/sha2.h
===================================================================
--- random/unix/sha2.h	(.../tags/1.2.2)	(wersja 358281)
+++ random/unix/sha2.h	(.../branches/1.2.x)	(wersja 358281)
@@ -57,23 +57,23 @@
 
 
 /*** SHA-256/384/512 Function Prototypes ******************************/
-void SHA256_Init(SHA256_CTX *);
-void SHA256_Update(SHA256_CTX *, const apr_byte_t *, size_t);
-void SHA256_Final(apr_byte_t [SHA256_DIGEST_LENGTH], SHA256_CTX *);
+void apr__SHA256_Init(SHA256_CTX *);
+void apr__SHA256_Update(SHA256_CTX *, const apr_byte_t *, size_t);
+void apr__SHA256_Final(apr_byte_t [SHA256_DIGEST_LENGTH], SHA256_CTX *);
 char* SHA256_End(SHA256_CTX *, char [SHA256_DIGEST_STRING_LENGTH]);
 char* SHA256_Data(const apr_byte_t *, size_t,
                   char [SHA256_DIGEST_STRING_LENGTH]);
 
-void SHA384_Init(SHA384_CTX *);
-void SHA384_Update(SHA384_CTX *, const apr_byte_t *, size_t);
-void SHA384_Final(apr_byte_t [SHA384_DIGEST_LENGTH], SHA384_CTX *);
+void apr__SHA384_Init(SHA384_CTX *);
+void apr__SHA384_Update(SHA384_CTX *, const apr_byte_t *, size_t);
+void apr__SHA384_Final(apr_byte_t [SHA384_DIGEST_LENGTH], SHA384_CTX *);
 char* SHA384_End(SHA384_CTX *, char [SHA384_DIGEST_STRING_LENGTH]);
 char* SHA384_Data(const apr_byte_t *, size_t,
                   char [SHA384_DIGEST_STRING_LENGTH]);
 
-void SHA512_Init(SHA512_CTX *);
-void SHA512_Update(SHA512_CTX *, const apr_byte_t *, size_t);
-void SHA512_Final(apr_byte_t [SHA512_DIGEST_LENGTH], SHA512_CTX *);
+void apr__SHA512_Init(SHA512_CTX *);
+void apr__SHA512_Update(SHA512_CTX *, const apr_byte_t *, size_t);
+void apr__SHA512_Final(apr_byte_t [SHA512_DIGEST_LENGTH], SHA512_CTX *);
 char* SHA512_End(SHA512_CTX *, char [SHA512_DIGEST_STRING_LENGTH]);
 char* SHA512_Data(const apr_byte_t *, size_t,
                   char [SHA512_DIGEST_STRING_LENGTH]);
Index: random/unix/sha2_glue.c
===================================================================
--- random/unix/sha2_glue.c	(.../tags/1.2.2)	(wersja 358281)
+++ random/unix/sha2_glue.c	(.../branches/1.2.x)	(wersja 358281)
@@ -5,18 +5,18 @@
 
 static void sha256_init(apr_crypto_hash_t *h)
     {
-    SHA256_Init(h->data);
+    apr__SHA256_Init(h->data);
     }
 
 static void sha256_add(apr_crypto_hash_t *h,const void *data,
 			  apr_size_t bytes)
     {
-    SHA256_Update(h->data,data,bytes);
+    apr__SHA256_Update(h->data,data,bytes);
     }
 
 static void sha256_finish(apr_crypto_hash_t *h,unsigned char *result)
     {
-    SHA256_Final(result,h->data);
+    apr__SHA256_Final(result,h->data);
     }
 
 APR_DECLARE(apr_crypto_hash_t *) apr_crypto_sha256_new(apr_pool_t *p)
Index: random/unix/sha2.c
===================================================================
--- random/unix/sha2.c	(.../tags/1.2.2)	(wersja 358281)
+++ random/unix/sha2.c	(.../branches/1.2.x)	(wersja 358281)
@@ -151,8 +151,8 @@
  * only.
  */
 void SHA512_Last(SHA512_CTX*);
-void SHA256_Transform(SHA256_CTX*, const sha2_word32*);
-void SHA512_Transform(SHA512_CTX*, const sha2_word64*);
+void apr__SHA256_Transform(SHA256_CTX*, const sha2_word32*);
+void apr__SHA512_Transform(SHA512_CTX*, const sha2_word64*);
 
 
 /*** SHA-XYZ INITIAL HASH VALUES AND CONSTANTS ************************/
@@ -264,7 +264,7 @@
 
 
 /*** SHA-256: *********************************************************/
-void SHA256_Init(SHA256_CTX* context) {
+void apr__SHA256_Init(SHA256_CTX* context) {
         if (context == (SHA256_CTX*)0) {
                 return;
         }
@@ -310,7 +310,7 @@
         (h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
         j++
 
-void SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) {
+void apr__SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) {
         sha2_word32     a, b, c, d, e, f, g, h, s0, s1;
         sha2_word32     T1, *W256;
         int             j;
@@ -368,7 +368,7 @@
 
 #else /* SHA2_UNROLL_TRANSFORM */
 
-void SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) {
+void apr__SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) {
         sha2_word32     a, b, c, d, e, f, g, h, s0, s1;
         sha2_word32     T1, T2, *W256;
         int             j;
@@ -448,7 +448,7 @@
 
 #endif /* SHA2_UNROLL_TRANSFORM */
 
-void SHA256_Update(SHA256_CTX* context, const sha2_byte *data, size_t len) {
+void apr__SHA256_Update(SHA256_CTX* context, const sha2_byte *data, size_t len) {
         unsigned int    freespace, usedspace;
 
         if (len == 0) {
@@ -471,7 +471,7 @@
                         context->bitcount += freespace << 3;
                         len -= freespace;
                         data += freespace;
-                        SHA256_Transform(context, (sha2_word32*)context->buffer);
+                        apr__SHA256_Transform(context, (sha2_word32*)context->buffer);
                 } else {
                         /* The buffer is not yet full */
                         MEMCPY_BCOPY(&context->buffer[usedspace], data, len);
@@ -483,7 +483,7 @@
         }
         while (len >= SHA256_BLOCK_LENGTH) {
                 /* Process as many complete blocks as we can */
-                SHA256_Transform(context, (sha2_word32*)data);
+                apr__SHA256_Transform(context, (sha2_word32*)data);
                 context->bitcount += SHA256_BLOCK_LENGTH << 3;
                 len -= SHA256_BLOCK_LENGTH;
                 data += SHA256_BLOCK_LENGTH;
@@ -497,7 +497,7 @@
         usedspace = freespace = 0;
 }
 
-void SHA256_Final(sha2_byte digest[], SHA256_CTX* context) {
+void apr__SHA256_Final(sha2_byte digest[], SHA256_CTX* context) {
         sha2_word32     *d = (sha2_word32*)digest;
         unsigned int    usedspace;
 
@@ -524,7 +524,7 @@
                                         MEMSET_BZERO(&context->buffer[usedspace], SHA256_BLOCK_LENGTH - usedspace);
                                 }
                                 /* Do second-to-last transform: */
-                                SHA256_Transform(context, (sha2_word32*)context->buffer);
+                                apr__SHA256_Transform(context, (sha2_word32*)context->buffer);
 
                                 /* And set-up for the last transform: */
                                 MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);
@@ -540,7 +540,7 @@
                 *(sha2_word64*)&context->buffer[SHA256_SHORT_BLOCK_LENGTH] = context->bitcount;
 
                 /* Final transform: */
-                SHA256_Transform(context, (sha2_word32*)context->buffer);
+                apr__SHA256_Transform(context, (sha2_word32*)context->buffer);
 
 #if !APR_IS_BIGENDIAN
                 {
@@ -569,7 +569,7 @@
         assert(context != (SHA256_CTX*)0);
 
         if (buffer != (char*)0) {
-                SHA256_Final(digest, context);
+                apr__SHA256_Final(digest, context);
 
                 for (i = 0; i < SHA256_DIGEST_LENGTH; i++) {
                         *buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
@@ -587,14 +587,14 @@
 char* SHA256_Data(const sha2_byte* data, size_t len, char digest[SHA256_DIGEST_STRING_LENGTH]) {
         SHA256_CTX      context;
 
-        SHA256_Init(&context);
-        SHA256_Update(&context, data, len);
+        apr__SHA256_Init(&context);
+        apr__SHA256_Update(&context, data, len);
         return SHA256_End(&context, digest);
 }
 
 
 /*** SHA-512: *********************************************************/
-void SHA512_Init(SHA512_CTX* context) {
+void apr__SHA512_Init(SHA512_CTX* context) {
         if (context == (SHA512_CTX*)0) {
                 return;
         }
@@ -639,7 +639,7 @@
         (h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
         j++
 
-void SHA512_Transform(SHA512_CTX* context, const sha2_word64* data) {
+void apr__SHA512_Transform(SHA512_CTX* context, const sha2_word64* data) {
         sha2_word64     a, b, c, d, e, f, g, h, s0, s1;
         sha2_word64     T1, *W512 = (sha2_word64*)context->buffer;
         int             j;
@@ -694,7 +694,7 @@
 
 #else /* SHA2_UNROLL_TRANSFORM */
 
-void SHA512_Transform(SHA512_CTX* context, const sha2_word64* data) {
+void apr__SHA512_Transform(SHA512_CTX* context, const sha2_word64* data) {
         sha2_word64     a, b, c, d, e, f, g, h, s0, s1;
         sha2_word64     T1, T2, *W512 = (sha2_word64*)context->buffer;
         int             j;
@@ -772,7 +772,7 @@
 
 #endif /* SHA2_UNROLL_TRANSFORM */
 
-void SHA512_Update(SHA512_CTX* context, const sha2_byte *data, size_t len) {
+void apr__SHA512_Update(SHA512_CTX* context, const sha2_byte *data, size_t len) {
         unsigned int    freespace, usedspace;
 
         if (len == 0) {
@@ -795,7 +795,7 @@
                         ADDINC128(context->bitcount, freespace << 3);
                         len -= freespace;
                         data += freespace;
-                        SHA512_Transform(context, (sha2_word64*)context->buffer);
+                        apr__SHA512_Transform(context, (sha2_word64*)context->buffer);
                 } else {
                         /* The buffer is not yet full */
                         MEMCPY_BCOPY(&context->buffer[usedspace], data, len);
@@ -807,7 +807,7 @@
         }
         while (len >= SHA512_BLOCK_LENGTH) {
                 /* Process as many complete blocks as we can */
-                SHA512_Transform(context, (sha2_word64*)data);
+                apr__SHA512_Transform(context, (sha2_word64*)data);
                 ADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);
                 len -= SHA512_BLOCK_LENGTH;
                 data += SHA512_BLOCK_LENGTH;
@@ -843,7 +843,7 @@
                                 MEMSET_BZERO(&context->buffer[usedspace], SHA512_BLOCK_LENGTH - usedspace);
                         }
                         /* Do second-to-last transform: */
-                        SHA512_Transform(context, (sha2_word64*)context->buffer);
+                        apr__SHA512_Transform(context, (sha2_word64*)context->buffer);
 
                         /* And set-up for the last transform: */
                         MEMSET_BZERO(context->buffer, SHA512_BLOCK_LENGTH - 2);
@@ -860,10 +860,10 @@
         *(sha2_word64*)&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8] = context->bitcount[0];
 
         /* Final transform: */
-        SHA512_Transform(context, (sha2_word64*)context->buffer);
+        apr__SHA512_Transform(context, (sha2_word64*)context->buffer);
 }
 
-void SHA512_Final(sha2_byte digest[], SHA512_CTX* context) {
+void apr__SHA512_Final(sha2_byte digest[], SHA512_CTX* context) {
         sha2_word64     *d = (sha2_word64*)digest;
 
         /* Sanity check: */
@@ -900,7 +900,7 @@
         assert(context != (SHA512_CTX*)0);
 
         if (buffer != (char*)0) {
-                SHA512_Final(digest, context);
+                apr__SHA512_Final(digest, context);
 
                 for (i = 0; i < SHA512_DIGEST_LENGTH; i++) {
                         *buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
@@ -918,14 +918,14 @@
 char* SHA512_Data(const sha2_byte* data, size_t len, char digest[SHA512_DIGEST_STRING_LENGTH]) {
         SHA512_CTX      context;
 
-        SHA512_Init(&context);
-        SHA512_Update(&context, data, len);
+        apr__SHA512_Init(&context);
+        apr__SHA512_Update(&context, data, len);
         return SHA512_End(&context, digest);
 }
 
 
 /*** SHA-384: *********************************************************/
-void SHA384_Init(SHA384_CTX* context) {
+void apr__SHA384_Init(SHA384_CTX* context) {
         if (context == (SHA384_CTX*)0) {
                 return;
         }
@@ -934,11 +934,11 @@
         context->bitcount[0] = context->bitcount[1] = 0;
 }
 
-void SHA384_Update(SHA384_CTX* context, const sha2_byte* data, size_t len) {
-        SHA512_Update((SHA512_CTX*)context, data, len);
+void apr__SHA384_Update(SHA384_CTX* context, const sha2_byte* data, size_t len) {
+        apr__SHA512_Update((SHA512_CTX*)context, data, len);
 }
 
-void SHA384_Final(sha2_byte digest[], SHA384_CTX* context) {
+void apr__SHA384_Final(sha2_byte digest[], SHA384_CTX* context) {
         sha2_word64     *d = (sha2_word64*)digest;
 
         /* Sanity check: */
@@ -975,7 +975,7 @@
         assert(context != (SHA384_CTX*)0);
 
         if (buffer != (char*)0) {
-                SHA384_Final(digest, context);
+                apr__SHA384_Final(digest, context);
 
                 for (i = 0; i < SHA384_DIGEST_LENGTH; i++) {
                         *buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
@@ -993,8 +993,8 @@
 char* SHA384_Data(const sha2_byte* data, size_t len, char digest[SHA384_DIGEST_STRING_LENGTH]) {
         SHA384_CTX      context;
 
-        SHA384_Init(&context);
-        SHA384_Update(&context, data, len);
+        apr__SHA384_Init(&context);
+        apr__SHA384_Update(&context, data, len);
         return SHA384_End(&context, digest);
 }
 
Index: include/apr_poll.h
===================================================================
--- include/apr_poll.h	(.../tags/1.2.2)	(wersja 358281)
+++ include/apr_poll.h	(.../branches/1.2.x)	(wersja 358281)
@@ -167,17 +167,19 @@
 
 
 /**
- * Poll the sockets in the poll structure
+ * Poll the descriptors in the poll structure
  * @param aprset The poll structure we will be using. 
- * @param numsock The number of sockets we are polling
- * @param nsds The number of sockets signalled.
+ * @param numsock The number of descriptors we are polling
+ * @param nsds The number of descriptors signalled.
  * @param timeout The amount of time in microseconds to wait.  This is 
- *                a maximum, not a minimum.  If a socket is signalled, we 
+ *                a maximum, not a minimum.  If a descriptor is signalled, we 
  *                will wake up before this time.  A negative number means 
- *                wait until a socket is signalled.
- * @remark The number of sockets signalled is returned in the third argument. 
+ *                wait until a descriptor is signalled.
+ * @remark The number of descriptors signalled is returned in the third argument. 
  *         This is a blocking call, and it will not return until either a 
- *         socket has been signalled, or the timeout has expired. 
+ *         descriptor has been signalled, or the timeout has expired. 
+ * @remark The rtnevents field in the apr_pollfd_t array will only be filled-
+ *         in if the return value is APR_SUCCESS.
  */
 APR_DECLARE(apr_status_t) apr_poll(apr_pollfd_t *aprset, apr_int32_t numsock,
                                    apr_int32_t *nsds, 
Index: include/apr.hw
===================================================================
--- include/apr.hw	(.../tags/1.2.2)	(wersja 358281)
+++ include/apr.hw	(.../branches/1.2.x)	(wersja 358281)
@@ -56,6 +56,14 @@
  */
 #pragma warning(disable: 4100 4127 4163 4201 4514; once: 4057 4075 4244)
 
+/* Ignore Microsoft's interpretation of secure development
+ * and the POSIX string handling API
+ */
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+#define _CRT_SECURE_NO_DEPRECATE
+#pragma warning(disable: 4996)
+#endif
+
 /* Has windows.h already been included?  If so, our preferences don't matter,
  * but we will still need the winsock things no matter what was included.
  * If not, include a restricted set of windows headers to our tastes.
@@ -506,6 +514,14 @@
 #pragma warning(pop)
 #endif
 
+/* Ignore Microsoft's interpretation of secure development 
+ * and their opinion of the POSIX standard string handling API
+ */
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+#define _CRT_SECURE_NO_DEPRECATE
+#pragma warning(disable: 4996)
+#endif
+
 #endif /* WIN32 */
 
 #endif /* APR_H */
Index: configure.in
===================================================================
--- configure.in	(.../tags/1.2.2)	(wersja 358281)
+++ configure.in	(.../branches/1.2.x)	(wersja 358281)
@@ -319,23 +319,6 @@
     fi
   ])
 
-dnl Electric Fence malloc checker.
-dnl --with-efence specifies the path to Electric Fence
-AC_ARG_WITH(efence, 
-  [  --with-efence[[=DIR]]     path to Electric Fence installation], 
-  [ apr_efence_dir="$withval"
-    if test "$apr_efence_dir" != "yes"; then
-      APR_ADDTO(LDFLAGS,[-L$apr_efence_dir/lib])
-      if test "x$apr_platform_runtime_link_flag" != "x"; then
-          APR_ADDTO(LDFLAGS, 
-                    [$apr_platform_runtime_link_flag$apr_efence_dir/lib])
-      fi
-    fi
-    AC_CHECK_LIB(efence, malloc, 
-                 [ APR_ADDTO(LIBS,-lefence) ],
-                 [ AC_MSG_ERROR(Electric Fence requested but not detected) ])
-  ])
-
 if test "$host" = "i586-pc-beos"; then
   AC_ARG_ENABLE(malloc-debug,[  --enable-malloc-debug   Switch on malloc_debug for BeOS],
     APR_REMOVEFROM(CFLAGS, -O2)
@@ -643,6 +626,25 @@
     echo "APR will be non-threaded"
 fi
 
+dnl Electric Fence malloc checker.
+dnl --with-efence specifies the path to Electric Fence.
+dnl This test should remain after the threads checks since libefence
+dnl may depend on libpthread.
+AC_ARG_WITH(efence, 
+  [  --with-efence[[=DIR]]     path to Electric Fence installation], 
+  [ apr_efence_dir="$withval"
+    if test "$apr_efence_dir" != "yes"; then
+      APR_ADDTO(LDFLAGS,[-L$apr_efence_dir/lib])
+      if test "x$apr_platform_runtime_link_flag" != "x"; then
+          APR_ADDTO(LDFLAGS, 
+                    [$apr_platform_runtime_link_flag$apr_efence_dir/lib])
+      fi
+    fi
+    AC_CHECK_LIB(efence, malloc, 
+                 [ APR_ADDTO(LIBS,-lefence) ],
+                 [ AC_MSG_ERROR(Electric Fence requested but not detected) ])
+  ])
+
 AC_CHECK_FUNCS(sigsuspend, [ have_sigsuspend="1" ], [ have_sigsuspend="0" ])
 AC_CHECK_FUNCS(sigwait, [ have_sigwait="1" ], [ have_sigwait="0" ]) 
 dnl AC_CHECK_FUNCS doesn't work for this on Tru64 since the function
Index: threadproc/unix/proc.c
===================================================================
--- threadproc/unix/proc.c	(.../tags/1.2.2)	(wersja 358281)
+++ threadproc/unix/proc.c	(.../branches/1.2.x)	(wersja 358281)
@@ -326,7 +326,15 @@
                                           apr_pool_t *pool)
 {
     int i;
+    const char * const empty_envp[] = {NULL};
 
+    if (!env) { /* Specs require an empty array instead of NULL;
+                 * Purify will trigger a failure, even if many
+                 * implementations don't.
+                 */
+        env = empty_envp;
+    }
+
     new->in = attr->parent_in;
     new->err = attr->parent_err;
     new->out = attr->parent_out;
Index: threadproc/unix/procsup.c
===================================================================
--- threadproc/unix/procsup.c	(.../tags/1.2.2)	(wersja 358281)
+++ threadproc/unix/procsup.c	(.../branches/1.2.x)	(wersja 358281)
@@ -20,7 +20,10 @@
 {
     int x;
 
-    chdir("/");
+    if (chdir("/") == -1) {
+        return errno;
+    }
+
 #if !defined(MPE) && !defined(OS2) && !defined(TPF) && !defined(BEOS)
     /* Don't detach for MPE because child processes can't survive the death of
      * the parent. */
Index: NWGNUmakefile
===================================================================
--- NWGNUmakefile	(.../tags/1.2.2)	(wersja 358281)
+++ NWGNUmakefile	(.../branches/1.2.x)	(wersja 358281)
@@ -211,7 +211,6 @@
 FILES_nlm_modules += \
 	lldapsdk \
 	lldapssl \
-	lldapx \
 	$(EOLIST)
 endif
 
Index: build/apr_common.m4
===================================================================
--- build/apr_common.m4	(.../tags/1.2.2)	(wersja 358281)
+++ build/apr_common.m4	(.../branches/1.2.x)	(wersja 358281)
@@ -471,40 +471,29 @@
 
 dnl
 dnl APR_TRY_COMPILE_NO_WARNING(INCLUDES, FUNCTION-BODY,
-dnl             [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]])
+dnl             [ACTIONS-IF-NO-WARNINGS], [ACTIONS-IF-WARNINGS])
 dnl
 dnl Tries a compile test with warnings activated so that the result
-dnl is false if the code doesn't compile cleanly.
+dnl is false if the code doesn't compile cleanly.  For compilers
+dnl where it is not known how to activate a "fail-on-error" mode,
+dnl it is undefined which of the sets of actions will be run.
 dnl
-AC_DEFUN(APR_TRY_COMPILE_NO_WARNING,
-[if test "x$CFLAGS_WARN" = "x"; then
-  apr_tcnw_flags=""
-else
-  apr_tcnw_flags=$CFLAGS_WARN
-fi
-if test "$ac_cv_prog_gcc" = "yes"; then 
-  apr_tcnw_flags="$apr_tcnw_flags -Werror"
-fi
-changequote(', ')
-cat > conftest.$ac_ext <<EOTEST
-#include "confdefs.h"
-'$1'
-int main(int argc, const char * const argv[]) {
-'$2'
-; return 0; }
-EOTEST
-changequote([, ])
-if ${CC-cc} -c $CFLAGS $CPPFLAGS $apr_tcnw_flags conftest.$ac_ext 2>&AC_FD_CC ; then
-  ifelse([$3], , :, [rm -rf conftest*
-  $3])
-else
-  echo "configure: failed or warning program:" >&AC_FD_CC
-  cat conftest.$ac_ext >&AC_FD_CC
-  ifelse([$4], , , [rm -rf conftest*
-  $4])
-fi
-rm -f conftest*
-])dnl
+AC_DEFUN([APR_TRY_COMPILE_NO_WARNING],
+[apr_save_CFLAGS=$CFLAGS
+ CFLAGS="$CFLAGS $CFLAGS_WARN"
+ if test "$ac_cv_prog_gcc" = "yes"; then 
+   CFLAGS="$CFLAGS -Werror"
+ fi
+ AC_COMPILE_IFELSE(
+  [#include "confdefs.h"
+  ]
+  [[$1]]
+  [int main(int argc, const char *const *argv) {]
+  [[$2]]
+  [   return 0; }],
+  [$3], [$4])
+ CFLAGS=$apr_save_CFLAGS
+])
 
 dnl
 dnl APR_CHECK_STRERROR_R_RC
Index: file_io/unix/seek.c
===================================================================
--- file_io/unix/seek.c	(.../tags/1.2.2)	(wersja 358281)
+++ file_io/unix/seek.c	(.../branches/1.2.x)	(wersja 358281)
@@ -19,32 +19,33 @@
 static apr_status_t setptr(apr_file_t *thefile, apr_off_t pos )
 {
     apr_off_t newbufpos;
-    int rc;
+    apr_status_t rv;
 
     if (thefile->direction == 1) {
-        apr_file_flush(thefile);
+        rv = apr_file_flush(thefile);
+        if (rv) {
+            return rv;
+        }
         thefile->bufpos = thefile->direction = thefile->dataRead = 0;
     }
 
     newbufpos = pos - (thefile->filePtr - thefile->dataRead);
     if (newbufpos >= 0 && newbufpos <= thefile->dataRead) {
         thefile->bufpos = newbufpos;
-        rc = 0;
+        rv = APR_SUCCESS;
     } 
     else {
-        rc = lseek(thefile->filedes, pos, SEEK_SET);
-
-        if (rc != -1 ) {
+        if (lseek(thefile->filedes, pos, SEEK_SET) != -1) {
             thefile->bufpos = thefile->dataRead = 0;
             thefile->filePtr = pos;
-            rc = 0;
+            rv = APR_SUCCESS;
         }
         else {
-            rc = errno;
+            rv = errno;
         }
     }
 
-    return rc;
+    return rv;
 }
 
 
Index: file_io/unix/fullrw.c
===================================================================
--- file_io/unix/fullrw.c	(.../tags/1.2.2)	(wersja 358281)
+++ file_io/unix/fullrw.c	(.../branches/1.2.x)	(wersja 358281)
@@ -68,7 +68,7 @@
                                                apr_size_t *bytes_written)
 {
     apr_status_t rv = APR_SUCCESS;
-    int i;
+    apr_size_t i;
     apr_size_t amt = 0;
     apr_size_t total = 0;
 
Index: poll/unix/select.c
===================================================================
--- poll/unix/select.c	(.../tags/1.2.2)	(wersja 358281)
+++ poll/unix/select.c	(.../branches/1.2.x)	(wersja 358281)
@@ -131,6 +131,7 @@
         return apr_get_netos_error();
     }
 
+    (*nsds) = 0;
     for (i = 0; i < num; i++) {
         apr_os_sock_t fd;
 
@@ -156,6 +157,9 @@
         if (FD_ISSET(fd, &exceptset)) {
             aprset[i].rtnevents |= APR_POLLERR;
         }
+        if (aprset[i].rtnevents) {
+            (*nsds)++;
+        }
     }
 
     return APR_SUCCESS;
@@ -395,6 +399,7 @@
             j++;
         }
     }
+    (*num) = j;
 
     if (descriptors)
         *descriptors = pollset->result_set;
Index: poll/unix/poll.c
===================================================================
--- poll/unix/poll.c	(.../tags/1.2.2)	(wersja 358281)
+++ poll/unix/poll.c	(.../branches/1.2.x)	(wersja 358281)
@@ -117,8 +117,13 @@
     i = poll(pollset, num_to_poll, timeout);
     (*nsds) = i;
 
-    for (i = 0; i < num; i++) {
-        aprset[i].rtnevents = get_revent(pollset[i].revents);
+    if (i > 0) { /* poll() sets revents only if an event was signalled;
+                  * we don't promise to set rtnevents unless an event
+                  * was signalled
+                  */
+        for (i = 0; i < num; i++) {
+            aprset[i].rtnevents = get_revent(pollset[i].revents);
+        }
     }
     
 #if !defined(HAVE_VLA) && !defined(HAVE_ALLOCA)
